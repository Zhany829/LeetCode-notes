解法：如果i是偶数，则说明他和i/2的1的数量一样。因为本质就是bit都向左移动一位，如果i是奇数则先减1--变成偶数--当前index-1的1数量再+1
用i&(i-1)得到以上，因为如果i是奇数则去掉最末尾的1得到比他小1的偶数的1的数量，因为i比这个偶数多最后一位的1所以+1
如果i是偶数，则去掉最后一个1得到1的数量，再加（补)回来一个1

class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for (int i = 1; i < n+1; i++) {
            res[i] = res[i&(i-1)] + 1; //去掉尾部的1的数的数量再+1
        }
        return res;
    }
}
