由于我们最多可以完成两笔交易，因此在任意一天结束之后，我们会处于以下五个状态中的一种：

未进行过任何操作；

只进行过一次买操作；

进行了一次买操作和一次卖操作，即完成了一笔交易；

在完成了一笔交易的前提下，进行了第二次买操作；

完成了全部两笔交易。

由于第一个状态的利润显然为 00，因此我们可以不用将其记录。对于剩下的四个状态，我们分别将它们的最大利润记为 
buy1
sell1
buy2
sell2

如果我们知道了第i−1 天结束后的这四个状态，那么如何通过状态转移方程得到第 i 天结束后的这四个状态呢？

对于buy1而言，在第i天我们可以不进行任何操作，保持不变，也可以在未进行任何操作的前提下以prices[i]的价格买入股票，那么buy1的状态转移方程即为：

buy1=max{'buy1,−prices[i]}

这里我们用'buy1表示第i−1 天的状态，以便于和第i天的状态buy1进行区分。

对于sell1而言，在第i天我们可以不进行任何操作，保持不变，也可以在只进行过一次买操作的前提下以prices[i] 的价格卖出股票，那么sell1的状态转移方程即为：

sell1=max{sell1,buy 1+prices[i]}

同理我们可以得到buy2和sell2

在考虑边界条件时，我们需要理解下面的这个事实：

无论题目中是否允许「在同一天买入并且卖出」这一操作，最终的答案都不会受到影响，这是因为这一操作带来的收益为零。

我们同样可以直接根据第 ii 天计算出的值来进行状态转移。

那么对于边界条件，我们考虑第i=0天时的四个状态：buy1即为以prices[0]的价格买入股票，因此buy1 = −prices[0]；
即为在同一天买入并且卖出，因此sell1=0；
buy2即为在同一天买入并且卖出后再以prices[0]的价格买入股票，因此buy2 = −prices[0]；同理可得sell 2=0。我们将这四个状态作为边界条件，从i=1开始进行动态规划，即可得到答案。

在动态规划结束后，由于我们可以进行不超过两笔交易，因此最终的答案在0，sell1，sell2中，且为三者中的最大值。
然而我们可以发现，由于在边界条件中sell1和sell2的值已经为0，并且在状态转移的过程中我们维护的是最大值，因此sell1和sell2最终一定大于等于0。
同时，如果最优的情况对应的是恰好一笔交易，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从sell1转移至sell2 
因此最终的答案即为sell2


class Solution {
    public int maxProfit(int[] prices) {
        int buy1 = -prices[0], sell1 = 0;
        int buy2 = -prices[0], sell2 = 0;
        for (int i = 1; i <prices.length; i++) {
            buy1 = Math.max(buy1, -prices[i]);
            sell1 = Math.max(sell1, buy1 + prices[i]);
            buy2 = Math.max(buy2, sell1-prices[i]);
            sell2 = Math.max(sell2, buy2 + prices[i]);
        }
        return sell2;
    }
}
