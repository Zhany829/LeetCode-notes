解法1：dfs一般都是stack+递归，探索m*n每一块，每次开始探索到一块，加上他四周面积，如果上面是1，那就往上去探索，
每次探索要1.判断是否超出边界 2.把探索过的地方标记成0.最后返回从这块探索的最大area，取探索每一块返回的area里的最大值

class Solution {
    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int max = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                max = Math.max(max, dfs(i, j, grid)); //对每一个点进行探索
            }
        }
        return max;
    }
    private int dfs(int i, int j, int[][] grid) {
        //搜索到超出边界的点不加面积
        if (i < 0 || i > grid.length-1 || j < 0 || j > grid[0].length-1 || grid[i][j] == 0) { 
            return 0;
        }
        grid[i][j] = 0; //给搜索到的点标记为0，表示访问过
        int area = 1;
        for (int[] d : directions) {  // 去这个点四周看，增加area的值
            area += dfs(i+d[0], j+d[1], grid);
        }
        return area;
    }
}
解法2:同样遍历岛屿每个点(里面会判断当前点是不是0，所以不用担心效率)，每次把当前的节点加到queue里，然后把当前节点置0同时++cur岛屿。
然后开始往岛屿四周探索，把四周的点不管是不是1都加到queue里，只要queue不为0就一直执行这个步骤，因为这样代表从这个点开始把所有联通的面积都能探索到。
每次探索完(queue empty)，就比较一下cur岛屿面积是不是最大，记录最大值
class Solution {
    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
    int m,n;
    public int maxAreaOfIsland(int[][] grid) {
        m = grid.length;
        n = grid[0].length;
        int max = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int cur = 0;
                 Queue<int[]> queue = new LinkedList<>();
                 queue.add(new int[]{i, j}); //把当前节点加入queue
                 while (!queue.isEmpty()) { //对这个点四周去探索，把探索到的加到queue，同时要置0和++面积
                    int[] curPosi = queue.poll();
                    int x = curPosi[0];
                    int y = curPosi[1];
                    if (x < 0 || x > m-1 || y < 0 || y > n-1 || grid[x][y] == 0) continue;
                    cur++;
                    grid[x][y] = 0;
                    for (int[] d :directions) {
                        queue.add(new int[]{x+d[0], y+d[1]});
                    }
                }
                max = Math.max(max, cur); //每次结束探索都看看这次探索的面积是不是最大的
        }
    }
    return max;
    }
}
解法3:这个岛屿面积太大，就要用并查集
Union就是把两个不相交的集合合并为一个集合
Find就是查询两个元素是否在同一个集合
并查集就是刚开始所有点都是一个独立子集，之后如果一个点赢了另一个点，比如和另一个点是连接的岛屿，就选择其中一个点作为代表元素。
合并两个集合里的点就去看他们的代表节点，也就是根节点的深度，把深度也就是rank(秩)小的作为深度/秩小往大的合并，合并后深度+1. 时间复杂度O(N)

class Solution {
int[] parent=null;
int[] size=null;
int max=0;
public void merge(int a,int b){
    int fa=find(a);
    int fb=find(b);
    if(fa==fb) return;
    if(size[fa]>size[fb]){
        parent[fb]=fa;
        size[fa]+=size[fb]; 
        max=Math.max(max,size[fa]); //统计最大值
    }else{
        parent[fa]=fb;
        size[fb]+=size[fa];
        max=Math.max(max,size[fb]);
    }
}
// 找到根节点,也就是当前集合的代表节点
public int find(int p){
    if(parent[p]==p) return p;
    parent[p]=find(parent[p]); //路径压缩
    return parent[p];
}
public int maxAreaOfIsland(int[][] grid) {
    int m=grid.length;
    int n=grid[0].length;
    //init
    parent=new int[m*n];
    size=new int[m*n];
    for (int i=0;i<m*n;i++){
        parent[i]=i; // 每个人先都是一个代表节点
        size[i]=1; //集合的大小为1
    }
    for (int i=0;i<m;i++) {
        for (int j=0;j<n;j++) {
            if(grid[i][j]==1){
                //特判一下 hahaha~ 感觉如果不是lc有wacase我还挺难发现这个
                max=Math.max(max,1);
                if(i>0 && grid[i-1][j]==1) merge(i*n+j,(i-1)*n+j); //合并上面
                if(j>0 && grid[i][j-1]==1) merge(i*n+j,i*n+j-1); //合并左边
            }
        }
    }
    return max;
}

}
